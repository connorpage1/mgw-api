# app.py - Ultra-Secure Flask API (Clean Version)
from flask import Flask, render_template, request, jsonify, redirect, url_for, flash
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from flask_security import Security, SQLAlchemyUserDatastore, UserMixin, RoleMixin, login_required, roles_required, current_user
from flask_security.utils import hash_password, verify_password
from flask_security.forms import RegisterForm, LoginForm
from flask_security.models import fsqla_v3 as fsqla
from flask_jwt_extended import JWTManager, jwt_required, create_access_token, get_jwt_identity, create_refresh_token
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
from flask_cors import CORS
from flask_wtf import FlaskForm
from flask_mail import Mail
from wtforms import StringField, TextAreaField, SelectField, SubmitField, IntegerField, BooleanField
from wtforms.validators import DataRequired, Length, Optional, Email
from datetime import datetime, timedelta
import os
import json
import secrets
from sqlalchemy import func, or_, text
from functools import wraps
import re
from argon2 import PasswordHasher
from argon2.exceptions import VerifyMismatchError
import logging
from logging.handlers import RotatingFileHandler

# Load environment variables
from dotenv import load_dotenv
if os.path.exists('.env.local'):
    load_dotenv('.env.local')
elif os.path.exists('.env'):
    load_dotenv('.env')

# Enhanced Security Configuration
class SecurityConfig:
    """Enhanced security configuration"""
    
    # Password Security - Using Argon2id (most secure)
    SECURITY_PASSWORD_HASH = 'argon2'
    SECURITY_PASSWORD_SALT = os.environ.get('SECURITY_PASSWORD_SALT', secrets.token_hex(32))
    
    # Argon2 Parameters (OWASP recommended)
    SECURITY_PASSWORD_HASH_OPTIONS = {
        'argon2': {
            'memory_cost': 102400,  # 100 MB
            'time_cost': 2,         # 2 iterations
            'parallelism': 8,       # 8 parallel threads
        }
    }
    
    # Session Security
    SECURITY_CSRF_PROTECT_MECHANISMS = ['session', 'basic']
    SECURITY_CSRF_IGNORE_UNAUTH_ENDPOINTS = True
    
    # Login Security
    SECURITY_LOGIN_ERROR_VIEW = '/auth/login-error'
    SECURITY_POST_LOGIN_REDIRECT_ENDPOINT = '/admin/dashboard'
    SECURITY_POST_LOGOUT_REDIRECT_ENDPOINT = '/auth/login'
    
    # Account Security
    SECURITY_REGISTERABLE = False  # Disable public registration
    SECURITY_RECOVERABLE = True    # Enable password recovery
    SECURITY_TRACKABLE = True      # Track login attempts
    SECURITY_CHANGEABLE = True     # Allow password changes
    
    # Two-Factor Authentication (disabled for development)
    SECURITY_TWO_FACTOR = False
    SECURITY_TWO_FACTOR_REQUIRED = False
    
    # Email Configuration for Recovery
    SECURITY_EMAIL_SENDER = os.environ.get('SECURITY_EMAIL_SENDER', 'noreply@mardigrasworld.com')
    
    # Token Security
    SECURITY_RESET_PASSWORD_WITHIN = '2 hours'
    SECURITY_CONFIRM_EMAIL_WITHIN = '5 days'

# App Configuration
app = Flask(__name__)

# Basic Flask Configuration
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', secrets.token_hex(32))
app.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL', 'sqlite:///instance/mardi_gras_dev.db')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# Security Configuration
for attr in dir(SecurityConfig):
    if not attr.startswith('__'):
        app.config[attr] = getattr(SecurityConfig, attr)

# JWT Configuration
app.config['JWT_SECRET_KEY'] = os.environ.get('JWT_SECRET_KEY', secrets.token_hex(32))
app.config['JWT_ACCESS_TOKEN_EXPIRES'] = timedelta(hours=24)
app.config['JWT_REFRESH_TOKEN_EXPIRES'] = timedelta(days=30)
app.config['JWT_BLACKLIST_ENABLED'] = True
app.config['JWT_BLACKLIST_TOKEN_CHECKS'] = ['access', 'refresh']

# Mail Configuration
app.config['MAIL_SERVER'] = os.environ.get('MAIL_SERVER', 'localhost')
app.config['MAIL_PORT'] = int(os.environ.get('MAIL_PORT', '1025'))
app.config['MAIL_USE_TLS'] = os.environ.get('MAIL_USE_TLS', 'false').lower() in ['true', 'on', '1']
app.config['MAIL_USERNAME'] = os.environ.get('MAIL_USERNAME')
app.config['MAIL_PASSWORD'] = os.environ.get('MAIL_PASSWORD')

# Rate Limiting Configuration
app.config['RATELIMIT_STORAGE_URL'] = os.environ.get('REDIS_URL', 'memory://')

# CORS Configuration
ALLOWED_ORIGINS = os.environ.get('CORS_ORIGINS', 'http://localhost:3000,http://localhost:8000').split(',')

# Initialize Extensions
db = SQLAlchemy(app)
migrate = Migrate(app, db)
jwt = JWTManager(app)

# Rate limiting - handle Redis connection gracefully
try:
    limiter = Limiter(
        app,
        key_func=get_remote_address,
        default_limits=["200 per day", "50 per hour"]
    )
except Exception as e:
    print(f"⚠️ Rate limiting disabled (Redis not available): {e}")
    # Create a dummy limiter for development
    class DummyLimiter:
        def limit(self, *args, **kwargs):
            def decorator(f):
                return f
            return decorator
    limiter = DummyLimiter()

cors = CORS(app, origins=ALLOWED_ORIGINS)
mail = Mail(app)

# Enhanced Logging Setup
if not app.debug and not os.environ.get('FLASK_ENV') == 'development':
    if not os.path.exists('logs'):
        os.mkdir('logs')
    
    file_handler = RotatingFileHandler('logs/mardi_gras_api.log', maxBytes=10240000, backupCount=10)
    file_handler.setFormatter(logging.Formatter(
        '%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'
    ))
    file_handler.setLevel(logging.INFO)
    app.logger.addHandler(file_handler)
    app.logger.setLevel(logging.INFO)
    app.logger.info('Mardi Gras API startup')

# JWT Blacklist (in production, use Redis)
blacklisted_tokens = set()

@jwt.token_in_blocklist_loader
def check_if_token_revoked(jwt_header, jwt_payload):
    return jwt_payload['jti'] in blacklisted_tokens

# ==================== SECURITY MODELS ====================

# Setup Flask-Security tables
fsqla.FsModels.set_db_info(db)

class Role(db.Model, RoleMixin):
    __tablename__ = 'roles'
    id = db.Column(db.Integer(), primary_key=True)
    name = db.Column(db.String(80), unique=True)
    description = db.Column(db.String(255))
    permissions = db.Column(db.Text)

class User(db.Model, UserMixin):
    __tablename__ = 'users'
    
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(255), unique=True, nullable=False)
    username = db.Column(db.String(255), unique=True, nullable=True)
    password = db.Column(db.String(255), nullable=False)
    
    # Flask-Security fields
    fs_uniquifier = db.Column(db.String(64), unique=True, nullable=False)
    confirmed_at = db.Column(db.DateTime())
    active = db.Column(db.Boolean(), default=True)
    
    # Security tracking
    current_login_at = db.Column(db.DateTime())
    current_login_ip = db.Column(db.String(45))
    last_login_at = db.Column(db.DateTime())
    last_login_ip = db.Column(db.String(45))
    login_count = db.Column(db.Integer, default=0)
    
    # API Access
    api_key = db.Column(db.String(255), unique=True, nullable=True)
    api_key_created_at = db.Column(db.DateTime())
    api_calls_count = db.Column(db.Integer, default=0)
    
    # Custom fields
    first_name = db.Column(db.String(100))
    last_name = db.Column(db.String(100))
    organization = db.Column(db.String(200))
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    roles = db.relationship('Role', secondary='roles_users', backref=db.backref('users', lazy='dynamic'))

# Many-to-many relationship table
roles_users = db.Table('roles_users',
    db.Column('user_id', db.Integer(), db.ForeignKey('users.id')),
    db.Column('role_id', db.Integer(), db.ForeignKey('roles.id'))
)

class APIUsage(db.Model):
    __tablename__ = 'api_usage'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=True)
    endpoint = db.Column(db.String(200), nullable=False)
    method = db.Column(db.String(10), nullable=False)
    ip_address = db.Column(db.String(45))
    user_agent = db.Column(db.Text)
    response_code = db.Column(db.Integer)
    response_time = db.Column(db.Float)
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)
    
    user = db.relationship('User', backref='api_calls')

class SecurityAudit(db.Model):
    __tablename__ = 'security_audit'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=True)
    event_type = db.Column(db.String(100), nullable=False)
    ip_address = db.Column(db.String(45))
    user_agent = db.Column(db.Text)
    details = db.Column(db.Text)
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)
    
    user = db.relationship('User', backref='security_events')

class Category(db.Model):
    __tablename__ = 'categories'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), unique=True, nullable=False)
    slug = db.Column(db.String(100), unique=True, nullable=False)
    icon = db.Column(db.String(10), nullable=False)
    description = db.Column(db.Text)
    sort_order = db.Column(db.Integer, default=0)
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    created_by = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=True)
    
    # Relationships
    terms = db.relationship('Term', backref='category_rel', lazy=True, cascade='all, delete-orphan')
    creator = db.relationship('User', backref='created_categories')
    
    def to_dict(self):
        return {
            'id': self.id,
            'name': self.name,
            'slug': self.slug,
            'icon': self.icon,
            'description': self.description,
            'sort_order': self.sort_order,
            'is_active': self.is_active,
            'term_count': len([term for term in self.terms if term.is_active])
        }

class Term(db.Model):
    __tablename__ = 'terms'
    
    id = db.Column(db.Integer, primary_key=True)
    term = db.Column(db.String(200), unique=True, nullable=False)
    slug = db.Column(db.String(200), unique=True, nullable=False)
    pronunciation = db.Column(db.String(200), nullable=False)
    definition = db.Column(db.Text, nullable=False)
    etymology = db.Column(db.Text)
    example = db.Column(db.Text)
    difficulty = db.Column(db.String(20), nullable=False)
    category_id = db.Column(db.Integer, db.ForeignKey('categories.id'), nullable=False)
    view_count = db.Column(db.Integer, default=0)
    is_featured = db.Column(db.Boolean, default=False)
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    created_by = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=True)
    updated_by = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=True)
    
    # Relationships
    creator = db.relationship('User', foreign_keys=[created_by], backref='created_terms')
    updater = db.relationship('User', foreign_keys=[updated_by], backref='updated_terms')
    
    # Add indexes for better search performance
    __table_args__ = (
        db.Index('idx_term_search', 'term'),
        db.Index('idx_definition_search', 'definition'),
        db.Index('idx_difficulty', 'difficulty'),
        db.Index('idx_category', 'category_id'),
        db.Index('idx_featured', 'is_featured'),
        db.Index('idx_active', 'is_active'),
    )
    
    def to_dict(self, include_related=False):
        data = {
            'id': self.id,
            'term': self.term,
            'slug': self.slug,
            'pronunciation': self.pronunciation,
            'definition': self.definition,
            'etymology': self.etymology,
            'example': self.example,
            'difficulty': self.difficulty,
            'category': self.category_rel.name,
            'category_slug': self.category_rel.slug,
            'category_icon': self.category_rel.icon,
            'view_count': self.view_count,
            'is_featured': self.is_featured,
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat()
        }
        
        if include_related:
            data['related_terms'] = [rt.to_dict() for rt in self.get_related_terms()]
        
        return data
    
    def get_related_terms(self, limit=5):
        """Get related terms based on category"""
        return Term.query.filter(
            Term.category_id == self.category_id,
            Term.id != self.id,
            Term.is_active == True
        ).order_by(func.random()).limit(limit).all()

class SearchLog(db.Model):
    __tablename__ = 'search_logs'
    
    id = db.Column(db.Integer, primary_key=True)
    query = db.Column(db.String(500), nullable=False)
    results_count = db.Column(db.Integer, default=0)
    user_ip = db.Column(db.String(45))
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=True)
    endpoint = db.Column(db.String(100))
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    user = db.relationship('User', backref='searches')

# Setup Flask-Security
user_datastore = SQLAlchemyUserDatastore(db, User, Role)
security = Security(app, user_datastore)

# ==================== CUSTOM PASSWORD HASHER ====================

class SecurePasswordHasher:
    """Ultra-secure password hasher using Argon2id"""
    
    def __init__(self):
        self.ph = PasswordHasher(
            memory_cost=65536,   # 64 MB (reduced for development)
            time_cost=2,         # 2 iterations
            parallelism=4,       # 4 parallel threads (reduced for development)
            hash_len=32,         # 32 byte hash
            salt_len=16          # 16 byte salt
        )
    
    def hash_password(self, password: str) -> str:
        """Hash password with Argon2id"""
        try:
            return self.ph.hash(password)
        except Exception as e:
            app.logger.error(f"Password hashing failed: {e}")
            raise
    
    def verify_password(self, password: str, hash: str) -> bool:
        """Verify password against hash"""
        try:
            self.ph.verify(hash, password)
            return True
        except VerifyMismatchError:
            return False
        except Exception as e:
            app.logger.error(f"Password verification failed: {e}")
            return False
    
    def needs_rehash(self, hash: str) -> bool:
        """Check if password needs rehashing"""
        try:
            return self.ph.check_needs_rehash(hash)
        except Exception:
            return True

# Initialize secure password hasher
secure_hasher = SecurePasswordHasher()

# ==================== UTILITY DECORATORS ====================

def log_api_usage(f):
    """Log API usage"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        start_time = datetime.utcnow()
        user_id = None
        
        try:
            if current_user.is_authenticated:
                user_id = current_user.id
            else:
                user_id = get_jwt_identity()
        except:
            pass
        
        try:
            result = f(*args, **kwargs)
            end_time = datetime.utcnow()
            
            # Log usage
            log = APIUsage(
                user_id=user_id,
                endpoint=request.endpoint,
                method=request.method,
                ip_address=request.environ.get('HTTP_X_REAL_IP', request.remote_addr),
                user_agent=request.headers.get('User-Agent', '')[:500],
                response_code=200,
                response_time=(end_time - start_time).total_seconds()
            )
            
            db.session.add(log)
            db.session.commit()
            return result
            
        except Exception as e:
            end_time = datetime.utcnow()
            # Log error
            log = APIUsage(
                user_id=user_id,
                endpoint=request.endpoint,
                method=request.method,
                ip_address=request.environ.get('HTTP_X_REAL_IP', request.remote_addr),
                user_agent=request.headers.get('User-Agent', '')[:500],
                response_code=500,
                response_time=(end_time - start_time).total_seconds()
            )
            db.session.add(log)
            db.session.commit()
            raise
    
    return decorated_function

# ==================== AUTHENTICATION ROUTES ====================

@app.route('/auth/secure-login', methods=['POST'])
@limiter.limit("5 per minute")
def secure_login():
    """Secure login endpoint"""
    data = request.get_json()
    
    if not data or not data.get('email') or not data.get('password'):
        return jsonify({'error': 'Email and password required'}), 400
    
    # Find user by email
    user = User.query.filter_by(email=data['email'], active=True).first()
    
    if not user or not secure_hasher.verify_password(data['password'], user.password):
        return jsonify({'error': 'Invalid credentials'}), 401
    
    # Update login tracking
    user.last_login_at = user.current_login_at
    user.last_login_ip = user.current_login_ip
    user.current_login_at = datetime.utcnow()
    user.current_login_ip = request.environ.get('HTTP_X_REAL_IP', request.remote_addr)
    user.login_count = (user.login_count or 0) + 1
    
    db.session.commit()
    
    # Create tokens
    access_token = create_access_token(identity=user.id)
    refresh_token = create_refresh_token(identity=user.id)
    
    return jsonify({
        'access_token': access_token,
        'refresh_token': refresh_token,
        'user': {
            'id': user.id,
            'email': user.email,
            'username': user.username,
            'roles': [role.name for role in user.roles]
        }
    })

@app.route('/auth/logout', methods=['POST'])
@jwt_required()
def secure_logout():
    """Secure logout with token blacklisting"""
    from flask_jwt_extended import get_jwt
    
    jti = get_jwt()['jti']
    blacklisted_tokens.add(jti)
    
    return jsonify({'message': 'Successfully logged out'})

# ==================== PUBLIC API ROUTES ====================

@app.route('/glossary/terms')
@limiter.limit("100 per hour")
@log_api_usage
def api_terms():
    """Public API endpoint for terms"""
    query = request.args.get('search', '').strip()[:500]
    category_slug = request.args.get('category', '').strip()[:100]
    difficulty = request.args.get('difficulty', '').strip()
    limit = min(max(request.args.get('limit', 50, type=int), 1), 100)
    
    # Validate difficulty parameter
    if difficulty and difficulty not in ['tourist', 'local', 'expert']:
        return jsonify({'error': 'Invalid difficulty level'}), 400
    
    # Build query - only active terms
    terms_query = Term.query.join(Category).filter(
        Term.is_active == True,
        Category.is_active == True
    )
    
    if query:
        search_filter = or_(
            Term.term.ilike(f'%{query}%'),
            Term.definition.ilike(f'%{query}%')
        )
        terms_query = terms_query.filter(search_filter)
        log_search(query, terms_query.count())
    
    if category_slug:
        terms_query = terms_query.filter(Category.slug == category_slug)
    
    if difficulty:
        terms_query = terms_query.filter(Term.difficulty == difficulty)
    
    # Execute query
    terms = terms_query.order_by(Term.term).limit(limit).all()
    
    return jsonify({
        'terms': [term.to_dict() for term in terms],
        'count': len(terms),
        'total': terms_query.count() if len(terms) == limit else len(terms)
    })

@app.route('/glossary/term/<slug>')
@limiter.limit("200 per hour")
@log_api_usage
def api_term_detail(slug):
    """Get single term by slug"""
    term = Term.query.filter_by(slug=slug, is_active=True).first()
    if not term:
        return jsonify({'error': 'Term not found'}), 404
    
    # Increment view count
    term.view_count = Term.view_count + 1
    db.session.commit()
    
    return jsonify(term.to_dict(include_related=True))

@app.route('/glossary/categories')
@limiter.limit("100 per hour")
@log_api_usage
def api_categories():
    """Get all categories"""
    categories = Category.query.filter_by(is_active=True).order_by(Category.sort_order, Category.name).all()
    return jsonify({
        'categories': [cat.to_dict() for cat in categories]
    })

@app.route('/glossary/search/suggestions')
@limiter.limit("200 per hour")
@log_api_usage
def api_search_suggestions():
    """Get search suggestions"""
    query = request.args.get('q', '').strip()
    if len(query) < 2:
        return jsonify([])
    
    terms = Term.query.filter(
        Term.term.ilike(f'{query}%'),
        Term.is_active == True
    ).order_by(Term.view_count.desc()).limit(10).all()
    
    suggestions = [{'term': t.term, 'slug': t.slug} for t in terms]
    return jsonify(suggestions)

@app.route('/glossary/random')
@limiter.limit("100 per hour")
@log_api_usage
def api_random_term():
    """Get random term"""
    term = Term.query.filter_by(is_active=True).order_by(func.random()).first()
    if term:
        return jsonify(term.to_dict())
    return jsonify({'error': 'No terms found'}), 404

@app.route('/glossary/stats')
@limiter.limit("100 per hour")
@log_api_usage
def api_stats():
    """Get API statistics"""
    stats = {
        'total_terms': Term.query.filter_by(is_active=True).count(),
        'total_categories': Category.query.filter_by(is_active=True).count(),
        'total_views': db.session.query(func.sum(Term.view_count)).scalar() or 0,
        'difficulty_breakdown': {
            'tourist': Term.query.filter_by(difficulty='tourist', is_active=True).count(),
            'local': Term.query.filter_by(difficulty='local', is_active=True).count(),
            'expert': Term.query.filter_by(difficulty='expert', is_active=True).count()
        }
    }
    return jsonify(stats)

# ==================== ADMIN API ROUTES ====================

@app.route('/admin/terms', methods=['GET'])
@jwt_required()
def admin_get_terms():
    """Admin: Get all terms"""
    page = request.args.get('page', 1, type=int)
    per_page = min(request.args.get('per_page', 50, type=int), 100)
    
    terms = Term.query.order_by(Term.created_at.desc()).paginate(
        page=page, per_page=per_page, error_out=False
    )
    
    return jsonify({
        'terms': [term.to_dict() for term in terms.items],
        'pagination': {
            'page': terms.page,
            'pages': terms.pages,
            'per_page': terms.per_page,
            'total': terms.total,
            'has_next': terms.has_next,
            'has_prev': terms.has_prev
        }
    })

@app.route('/admin/terms', methods=['POST'])
@jwt_required()
def admin_create_term():
    """Admin: Create new term"""
    data = request.get_json()
    
    # Validate required fields
    required_fields = ['term', 'pronunciation', 'definition', 'difficulty', 'category_id']
    for field in required_fields:
        if not data.get(field):
            return jsonify({'error': f'{field} is required'}), 400
    
    # Check if term already exists
    if Term.query.filter_by(term=data['term']).first():
        return jsonify({'error': 'Term already exists'}), 400
    
    # Validate category
    category = Category.query.get(data['category_id'])
    if not category:
        return jsonify({'error': 'Invalid category'}), 400
    
    # Create term
    term = Term(
        term=data['term'],
        slug=create_slug(data['term']),
        pronunciation=data['pronunciation'],
        definition=data['definition'],
        etymology=data.get('etymology', ''),
        example=data.get('example', ''),
        difficulty=data['difficulty'],
        category_id=data['category_id'],
        is_featured=data.get('is_featured', False),
        created_by=get_jwt_identity()
    )
    
    try:
        db.session.add(term)
        db.session.commit()
        return jsonify(term.to_dict()), 201
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': 'Failed to create term'}), 500

# ==================== UTILITY FUNCTIONS ====================

def create_slug(text):
    """Create URL-friendly slug"""
    if not text:
        return ''
    
    text = str(text)[:200]
    slug = re.sub(r'[^\w\s-]', '', text.lower())
    slug = re.sub(r'[-\s]+', '-', slug)
    return slug.strip('-')

def log_search(query, results_count):
    """Log search query"""
    try:
        user_id = None
        try:
            if current_user.is_authenticated:
                user_id = current_user.id
            else:
                user_id = get_jwt_identity()
        except:
            pass
        
        search_log = SearchLog(
            query=query.strip()[:500],
            results_count=results_count,
            user_ip=request.environ.get('HTTP_X_REAL_IP', request.remote_addr),
            user_id=user_id,
            endpoint=request.endpoint
        )
        db.session.add(search_log)
        db.session.commit()
    except Exception as e:
        app.logger.error(f"Failed to log search: {e}")

# ==================== ERROR HANDLERS ====================

@app.errorhandler(404)
def not_found_error(error):
    return jsonify({'error': 'Resource not found'}), 404

@app.errorhandler(500)
def internal_error(error):
    db.session.rollback()
    return jsonify({'error': 'Internal server error'}), 500

@app.errorhandler(429)
def ratelimit_handler(e):
    return jsonify({
        'error': 'Rate limit exceeded',
        'retry_after': str(e.retry_after) if hasattr(e, 'retry_after') else '60'
    }), 429

@app.errorhandler(400)
def bad_request_error(error):
    return jsonify({'error': 'Bad request'}), 400

@app.errorhandler(401)
def unauthorized_error(error):
    return jsonify({'error': 'Unauthorized'}), 401

# ==================== JWT ERROR HANDLERS ====================

@jwt.expired_token_loader
def expired_token_callback(jwt_header, jwt_payload):
    return jsonify({'error': 'Token has expired'}), 401

@jwt.invalid_token_loader
def invalid_token_callback(error):
    return jsonify({'error': 'Invalid token'}), 401

@jwt.unauthorized_loader
def missing_token_callback(error):
    return jsonify({'error': 'Authentication required'}), 401

@jwt.revoked_token_loader
def revoked_token_callback(jwt_header, jwt_payload):
    return jsonify({'error': 'Token revoked'}), 401

# ==================== HEALTH CHECK ====================

@app.route('/health')
def health_check():
    """Health check endpoint"""
    try:
        # Test database connectivity
        db.session.execute(text('SELECT 1'))
        db_status = 'healthy'
    except Exception as e:
        db_status = f'unhealthy: {str(e)}'
    
    return jsonify({
        'status': 'healthy' if db_status == 'healthy' else 'degraded',
        'timestamp': datetime.utcnow().isoformat(),
        'version': '2.0.0-secure',
        'services': {
            'database': db_status,
            'security': 'active'
        }
    })

# ==================== DATABASE INITIALIZATION ====================

def init_db():
    """Initialize database"""
    try:
        # Create all tables
        db.create_all()
        print("✅ Database tables created")
        
        # Create default roles
        admin_role = Role.query.filter_by(name='admin').first()
        if not admin_role:
            admin_role = user_datastore.create_role(
                name='admin',
                description='Administrator with full access'
            )
            print("✅ Admin role created")
        
        # Create default admin user
        admin_email = os.environ.get('ADMIN_EMAIL', 'admin@dev.local')
        admin_user = User.query.filter_by(email=admin_email).first()
        
        if not admin_user:
            admin_password = os.environ.get('ADMIN_PASSWORD', 'DevAdmin123!@#')
            
            admin_user = user_datastore.create_user(
                email=admin_email,
                username=os.environ.get('ADMIN_USERNAME', 'admin'),
                password=secure_hasher.hash_password(admin_password),
                fs_uniquifier=secrets.token_hex(16),
                active=True,
                confirmed_at=datetime.utcnow()
            )
            
            # Add admin role
            user_datastore.add_role_to_user(admin_user, admin_role)
            
            # Generate API key
            admin_user.api_key = secrets.token_urlsafe(32)
            admin_user.api_key_created_at = datetime.utcnow()
            
            print(f"✅ Admin user created: {admin_email}")
            print(f"🔑 Admin API Key: {admin_user.api_key}")
        
        db.session.commit()
        print("✅ Database initialization completed successfully!")
        
    except Exception as e:
        print(f"❌ Database initialization failed: {e}")
        import traceback
        traceback.print_exc()
        raise

if __name__ == '__main__':
    print("🚀 Starting Mardi Gras API...")
    
    # Initialize database
    with app.app_context():
        init_db()
    
    # Start the development server
    port = int(os.environ.get('PORT', 5555))
    debug = os.environ.get('FLASK_DEBUG', 'True').lower() in ['true', '1', 'on']
    
    print(f"🌐 Server starting on http://localhost:{port}")
    print(f"🔧 Debug mode: {debug}")
    
    app.run(debug=debug, host='0.0.0.0', port=port)