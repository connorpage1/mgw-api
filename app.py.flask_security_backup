# app.py - Ultra-Secure Flask API (Final Fixed Version)
from flask import Flask, render_template, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from flask_security import Security, SQLAlchemyUserDatastore, UserMixin, RoleMixin, current_user
from flask_security.models import fsqla_v3 as fsqla
from flask_jwt_extended import JWTManager, jwt_required, create_access_token, get_jwt_identity, create_refresh_token
from flask_cors import CORS
from flask_mail import Mail
from datetime import datetime, timedelta
import os
import json
import secrets
from sqlalchemy import func, or_, text
from functools import wraps
import re
from argon2 import PasswordHasher
from argon2.exceptions import VerifyMismatchError
import logging

# Load environment variables
from dotenv import load_dotenv
if os.path.exists('.env.local'):
    load_dotenv('.env.local')
elif os.path.exists('.env'):
    load_dotenv('.env')

# App Configuration
app = Flask(__name__)

# Basic Flask Configuration
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', secrets.token_hex(32))
app.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL', 'sqlite:///instance/mardi_gras_dev.db')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# Security Configuration
app.config['SECURITY_PASSWORD_HASH'] = 'argon2'
app.config['SECURITY_PASSWORD_SALT'] = os.environ.get('SECURITY_PASSWORD_SALT', secrets.token_hex(32))
app.config['SECURITY_REGISTERABLE'] = False
app.config['SECURITY_RECOVERABLE'] = True
app.config['SECURITY_TRACKABLE'] = True
app.config['SECURITY_CHANGEABLE'] = True
app.config['SECURITY_TWO_FACTOR'] = False

# JWT Configuration
app.config['JWT_SECRET_KEY'] = os.environ.get('JWT_SECRET_KEY', secrets.token_hex(32))
app.config['JWT_ACCESS_TOKEN_EXPIRES'] = timedelta(hours=24)
app.config['JWT_REFRESH_TOKEN_EXPIRES'] = timedelta(days=30)

# Mail Configuration
app.config['MAIL_SERVER'] = os.environ.get('MAIL_SERVER', 'localhost')
app.config['MAIL_PORT'] = int(os.environ.get('MAIL_PORT', '1025'))
app.config['MAIL_USE_TLS'] = os.environ.get('MAIL_USE_TLS', 'false').lower() in ['true', 'on', '1']
app.config['MAIL_USERNAME'] = os.environ.get('MAIL_USERNAME')
app.config['MAIL_PASSWORD'] = os.environ.get('MAIL_PASSWORD')

# CORS Configuration
ALLOWED_ORIGINS = os.environ.get('CORS_ORIGINS', 'http://localhost:3000,http://localhost:8000').split(',')

# Initialize Extensions
db = SQLAlchemy(app)
migrate = Migrate(app, db)
jwt = JWTManager(app)
cors = CORS(app, origins=ALLOWED_ORIGINS)
mail = Mail(app)

# Rate Limiting - Simplified for development
class SimpleLimiter:
    """Simple rate limiter for development (no Redis required)"""
    def limit(self, *args, **kwargs):
        def decorator(f):
            return f
        return decorator

# Try to import real limiter, fall back to simple one
try:
    from flask_limiter import Limiter
    from flask_limiter.util import get_remote_address
    
    # Only use Redis if available
    redis_url = os.environ.get('REDIS_URL')
    if redis_url and redis_url != 'memory://':
        limiter = Limiter(
            key_func=get_remote_address,
            app=app,
            default_limits=["200 per day", "50 per hour"],
            storage_uri=redis_url
        )
        print("✅ Rate limiting enabled with Redis")
    else:
        limiter = SimpleLimiter()
        print("⚠️ Rate limiting disabled (Redis not configured)")
except ImportError:
    limiter = SimpleLimiter()
    print("⚠️ Rate limiting disabled (Flask-Limiter not available)")

# JWT Blacklist
blacklisted_tokens = set()

@jwt.token_in_blocklist_loader
def check_if_token_revoked(jwt_header, jwt_payload):
    return jwt_payload['jti'] in blacklisted_tokens

# ==================== DATABASE MODELS ====================

# Setup Flask-Security
fsqla.FsModels.set_db_info(db)

class Role(db.Model, RoleMixin):
    __tablename__ = 'roles'
    id = db.Column(db.Integer(), primary_key=True)
    name = db.Column(db.String(80), unique=True)
    description = db.Column(db.String(255))

class User(db.Model, UserMixin):
    __tablename__ = 'users'
    
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(255), unique=True, nullable=False)
    username = db.Column(db.String(255), unique=True, nullable=True)
    password = db.Column(db.String(255), nullable=False)
    
    # Flask-Security fields
    fs_uniquifier = db.Column(db.String(64), unique=True, nullable=False)
    confirmed_at = db.Column(db.DateTime())
    active = db.Column(db.Boolean(), default=True)
    
    # Security tracking
    current_login_at = db.Column(db.DateTime())
    current_login_ip = db.Column(db.String(45))
    last_login_at = db.Column(db.DateTime())
    last_login_ip = db.Column(db.String(45))
    login_count = db.Column(db.Integer, default=0)
    
    # API Access
    api_key = db.Column(db.String(255), unique=True, nullable=True)
    api_key_created_at = db.Column(db.DateTime())
    
    # Custom fields
    first_name = db.Column(db.String(100))
    last_name = db.Column(db.String(100))
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    roles = db.relationship('Role', secondary='roles_users', backref=db.backref('users', lazy='dynamic'))

# Define the roles_users table properly
roles_users = db.Table('roles_users',
    db.Column('user_id', db.Integer(), db.ForeignKey('users.id'), primary_key=True),
    db.Column('role_id', db.Integer(), db.ForeignKey('roles.id'), primary_key=True)
)

class Category(db.Model):
    __tablename__ = 'categories'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), unique=True, nullable=False)
    slug = db.Column(db.String(100), unique=True, nullable=False)
    icon = db.Column(db.String(10), nullable=False)
    description = db.Column(db.Text)
    sort_order = db.Column(db.Integer, default=0)
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    def to_dict(self):
        return {
            'id': self.id,
            'name': self.name,
            'slug': self.slug,
            'icon': self.icon,
            'description': self.description,
            'sort_order': self.sort_order,
            'is_active': self.is_active,
            'term_count': len([term for term in self.terms if term.is_active])
        }

class Term(db.Model):
    __tablename__ = 'terms'
    
    id = db.Column(db.Integer, primary_key=True)
    term = db.Column(db.String(200), unique=True, nullable=False)
    slug = db.Column(db.String(200), unique=True, nullable=False)
    pronunciation = db.Column(db.String(200), nullable=False)
    definition = db.Column(db.Text, nullable=False)
    etymology = db.Column(db.Text)
    example = db.Column(db.Text)
    difficulty = db.Column(db.String(20), nullable=False)
    category_id = db.Column(db.Integer, db.ForeignKey('categories.id'), nullable=False)
    view_count = db.Column(db.Integer, default=0)
    is_featured = db.Column(db.Boolean, default=False)
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    category_rel = db.relationship('Category', backref='terms')
    
    def to_dict(self, include_related=False):
        data = {
            'id': self.id,
            'term': self.term,
            'slug': self.slug,
            'pronunciation': self.pronunciation,
            'definition': self.definition,
            'etymology': self.etymology,
            'example': self.example,
            'difficulty': self.difficulty,
            'category': self.category_rel.name,
            'category_slug': self.category_rel.slug,
            'category_icon': self.category_rel.icon,
            'view_count': self.view_count,
            'is_featured': self.is_featured,
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat()
        }
        
        if include_related:
            data['related_terms'] = [rt.to_dict() for rt in self.get_related_terms()]
        
        return data
    
    def get_related_terms(self, limit=5):
        """Get related terms based on category"""
        return Term.query.filter(
            Term.category_id == self.category_id,
            Term.id != self.id,
            Term.is_active == True
        ).order_by(func.random()).limit(limit).all()

class SearchLog(db.Model):
    __tablename__ = 'search_logs'
    
    id = db.Column(db.Integer, primary_key=True)
    query = db.Column(db.String(500), nullable=False)
    results_count = db.Column(db.Integer, default=0)
    user_ip = db.Column(db.String(45))
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

# Setup Flask-Security
user_datastore = SQLAlchemyUserDatastore(db, User, Role)
security = Security(app, user_datastore)

# ==================== PASSWORD HASHER ====================

class SecurePasswordHasher:
    """Secure password hasher using Argon2id"""
    
    def __init__(self):
        self.ph = PasswordHasher(
            memory_cost=65536,   # 64 MB (reasonable for development)
            time_cost=2,         # 2 iterations
            parallelism=4,       # 4 parallel threads
            hash_len=32,         # 32 byte hash
            salt_len=16          # 16 byte salt
        )
    
    def hash_password(self, password: str) -> str:
        """Hash password with Argon2id"""
        return self.ph.hash(password)
    
    def verify_password(self, password: str, hash_str: str) -> bool:
        """Verify password against hash"""
        try:
            self.ph.verify(hash_str, password)
            return True
        except VerifyMismatchError:
            return False
        except Exception:
            return False

# Initialize password hasher
secure_hasher = SecurePasswordHasher()

# ==================== AUTHENTICATION ROUTES ====================

@app.route('/auth/secure-login', methods=['POST'])
@limiter.limit("5 per minute")
def secure_login():
    """Secure login endpoint"""
    data = request.get_json()
    
    if not data or not data.get('email') or not data.get('password'):
        return jsonify({'error': 'Email and password required'}), 400
    
    # Find user by email
    user = User.query.filter_by(email=data['email'], active=True).first()
    
    if not user or not secure_hasher.verify_password(data['password'], user.password):
        return jsonify({'error': 'Invalid credentials'}), 401
    
    # Update login tracking
    user.last_login_at = user.current_login_at
    user.last_login_ip = user.current_login_ip
    user.current_login_at = datetime.utcnow()
    user.current_login_ip = request.environ.get('HTTP_X_REAL_IP', request.remote_addr)
    user.login_count = (user.login_count or 0) + 1
    
    db.session.commit()
    
    # Create tokens
    access_token = create_access_token(identity=user.id)
    refresh_token = create_refresh_token(identity=user.id)
    
    return jsonify({
        'access_token': access_token,
        'refresh_token': refresh_token,
        'user': {
            'id': user.id,
            'email': user.email,
            'username': user.username,
            'roles': [role.name for role in user.roles]
        }
    })

@app.route('/auth/logout', methods=['POST'])
@jwt_required()
def secure_logout():
    """Secure logout"""
    from flask_jwt_extended import get_jwt
    
    jti = get_jwt()['jti']
    blacklisted_tokens.add(jti)
    
    return jsonify({'message': 'Successfully logged out'})

# ==================== PUBLIC API ROUTES ====================

@app.route('/glossary/terms')
@limiter.limit("100 per hour")
def api_terms():
    """Get terms with filtering"""
    query = request.args.get('search', '').strip()
    category_slug = request.args.get('category', '').strip()
    difficulty = request.args.get('difficulty', '').strip()
    limit = min(max(request.args.get('limit', 50, type=int), 1), 100)
    
    # Build query
    terms_query = Term.query.join(Category).filter(
        Term.is_active == True,
        Category.is_active == True
    )
    
    if query:
        search_filter = or_(
            Term.term.ilike(f'%{query}%'),
            Term.definition.ilike(f'%{query}%')
        )
        terms_query = terms_query.filter(search_filter)
        log_search(query, terms_query.count())
    
    if category_slug:
        terms_query = terms_query.filter(Category.slug == category_slug)
    
    if difficulty and difficulty in ['tourist', 'local', 'expert']:
        terms_query = terms_query.filter(Term.difficulty == difficulty)
    
    # Execute query
    terms = terms_query.order_by(Term.term).limit(limit).all()
    
    return jsonify({
        'terms': [term.to_dict() for term in terms],
        'count': len(terms)
    })

@app.route('/glossary/term/<slug>')
@limiter.limit("200 per hour")
def api_term_detail(slug):
    """Get single term"""
    term = Term.query.filter_by(slug=slug, is_active=True).first()
    if not term:
        return jsonify({'error': 'Term not found'}), 404
    
    # Increment view count
    term.view_count += 1
    db.session.commit()
    
    return jsonify(term.to_dict(include_related=True))

@app.route('/glossary/categories')
@limiter.limit("100 per hour")
def api_categories():
    """Get all categories"""
    categories = Category.query.filter_by(is_active=True).order_by(Category.sort_order, Category.name).all()
    return jsonify({
        'categories': [cat.to_dict() for cat in categories]
    })

@app.route('/glossary/random')
@limiter.limit("100 per hour")
def api_random_term():
    """Get random term"""
    term = Term.query.filter_by(is_active=True).order_by(func.random()).first()
    if term:
        return jsonify(term.to_dict())
    return jsonify({'error': 'No terms found'}), 404

@app.route('/glossary/stats')
@limiter.limit("100 per hour")
def api_stats():
    """Get API statistics"""
    stats = {
        'total_terms': Term.query.filter_by(is_active=True).count(),
        'total_categories': Category.query.filter_by(is_active=True).count(),
        'total_views': db.session.query(func.sum(Term.view_count)).scalar() or 0,
        'difficulty_breakdown': {
            'tourist': Term.query.filter_by(difficulty='tourist', is_active=True).count(),
            'local': Term.query.filter_by(difficulty='local', is_active=True).count(),
            'expert': Term.query.filter_by(difficulty='expert', is_active=True).count()
        }
    }
    return jsonify(stats)

# ==================== ADMIN ROUTES ====================

@app.route('/admin/terms', methods=['GET'])
@jwt_required()
def admin_get_terms():
    """Admin: Get all terms"""
    terms = Term.query.order_by(Term.created_at.desc()).limit(100).all()
    return jsonify({
        'terms': [term.to_dict() for term in terms],
        'total': Term.query.count()
    })

@app.route('/admin/terms', methods=['POST'])
@jwt_required()
def admin_create_term():
    """Admin: Create new term"""
    data = request.get_json()
    
    required_fields = ['term', 'pronunciation', 'definition', 'difficulty', 'category_id']
    for field in required_fields:
        if not data.get(field):
            return jsonify({'error': f'{field} is required'}), 400
    
    if Term.query.filter_by(term=data['term']).first():
        return jsonify({'error': 'Term already exists'}), 400
    
    category = Category.query.get(data['category_id'])
    if not category:
        return jsonify({'error': 'Invalid category'}), 400
    
    term = Term(
        term=data['term'],
        slug=create_slug(data['term']),
        pronunciation=data['pronunciation'],
        definition=data['definition'],
        etymology=data.get('etymology', ''),
        example=data.get('example', ''),
        difficulty=data['difficulty'],
        category_id=data['category_id'],
        is_featured=data.get('is_featured', False)
    )
    
    try:
        db.session.add(term)
        db.session.commit()
        return jsonify(term.to_dict()), 201
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': 'Failed to create term'}), 500

# ==================== UTILITY FUNCTIONS ====================

def create_slug(text):
    """Create URL-friendly slug"""
    if not text:
        return ''
    
    text = str(text)[:200]
    slug = re.sub(r'[^\w\s-]', '', text.lower())
    slug = re.sub(r'[-\s]+', '-', slug)
    return slug.strip('-')

def log_search(query, results_count):
    """Log search query"""
    try:
        search_log = SearchLog(
            query=query[:500],
            results_count=results_count,
            user_ip=request.environ.get('HTTP_X_REAL_IP', request.remote_addr)
        )
        db.session.add(search_log)
        db.session.commit()
    except Exception as e:
        print(f"Failed to log search: {e}")

# ==================== ERROR HANDLERS ====================

@app.errorhandler(404)
def not_found_error(error):
    return jsonify({'error': 'Resource not found'}), 404

@app.errorhandler(500)
def internal_error(error):
    db.session.rollback()
    return jsonify({'error': 'Internal server error'}), 500

@app.errorhandler(429)
def ratelimit_handler(e):
    return jsonify({'error': 'Rate limit exceeded'}), 429

# JWT Error Handlers
@jwt.expired_token_loader
def expired_token_callback(jwt_header, jwt_payload):
    return jsonify({'error': 'Token has expired'}), 401

@jwt.invalid_token_loader
def invalid_token_callback(error):
    return jsonify({'error': 'Invalid token'}), 401

@jwt.unauthorized_loader
def missing_token_callback(error):
    return jsonify({'error': 'Authentication required'}), 401

# ==================== HEALTH CHECK ====================

@app.route('/health')
def health_check():
    """Health check endpoint"""
    return jsonify({
        'status': 'healthy',
        'timestamp': datetime.utcnow().isoformat(),
        'version': '2.0.0'
    })

# ==================== DATABASE INITIALIZATION ====================

def init_db():
    """Initialize database"""
    try:
        print("🔄 Initializing database...")
        
        # Create all tables
        db.create_all()
        print("✅ Database tables created")
        
        # Create admin role
        admin_role = Role.query.filter_by(name='admin').first()
        if not admin_role:
            admin_role = Role(name='admin', description='Administrator')
            db.session.add(admin_role)
            print("✅ Admin role created")
        
        # Create admin user
        admin_email = os.environ.get('ADMIN_EMAIL', 'admin@dev.local')
        admin_user = User.query.filter_by(email=admin_email).first()
        
        if not admin_user:
            admin_password = os.environ.get('ADMIN_PASSWORD', 'DevAdmin123!@#')
            
            admin_user = User(
                email=admin_email,
                username=os.environ.get('ADMIN_USERNAME', 'admin'),
                password=secure_hasher.hash_password(admin_password),
                fs_uniquifier=secrets.token_hex(16),
                active=True,
                confirmed_at=datetime.utcnow()
            )
            
            db.session.add(admin_user)
            db.session.flush()  # Get the ID
            
            # Add admin role
            admin_user.roles.append(admin_role)
            
            # Generate API key
            admin_user.api_key = secrets.token_urlsafe(32)
            admin_user.api_key_created_at = datetime.utcnow()
            
            print(f"✅ Admin user created: {admin_email}")
            print(f"🔑 Admin API Key: {admin_user.api_key}")
        
        db.session.commit()
        print("✅ Database initialization completed!")
        
    except Exception as e:
        db.session.rollback()
        print(f"❌ Database initialization failed: {e}")
        import traceback
        traceback.print_exc()
        raise

if __name__ == '__main__':
    print("🚀 Starting Mardi Gras API...")
    
    # Initialize database
    with app.app_context():
        init_db()
    
    # Start server
    port = int(os.environ.get('PORT', 5555))
    debug = os.environ.get('FLASK_DEBUG', 'True').lower() in ['true', '1', 'on']
    
    print(f"🌐 Server starting on http://localhost:{port}")
    
    app.run(debug=debug, host='0.0.0.0', port=port)